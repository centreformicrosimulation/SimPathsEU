********************************************************************************
* PROJECT:  		ESPON
* SECTION:			Validation
* OBJECT:			Create validation targets
* AUTHORS:			Patryk Bronka, Ashley Burdett, Daria Popova 
* LAST UPDATE:		Feb 2025 (AB)
* COUNTRY: 			Greece  

* DESCRIPTION:      This file creates validation targets using EU SILC data 
* 					generated by do files


* NOTES: 			Consider winsorizing/trimming gross labour income at the 
*					bottom of the file. 
********************************************************************************

cd "${dir_data}" 	

use "${country}-eusilc_validation_sample_prep2.dta", clear 


* Restrict sample to observations up to and including specified maximum year
fre swv
keep if swv <= $max_year
gen year = stm 

* Further adjustments
* Define age groups
gen ageGroup = .
replace ageGroup = 0 if dag >= 0 & dag <= 14
replace ageGroup = 1 if dag >= 15 & dag <= 19
replace ageGroup = 2 if dag >= 20 & dag <= 24
replace ageGroup = 3 if dag >= 25 & dag <= 29
replace ageGroup = 4 if dag >= 30 & dag <= 34
replace ageGroup = 5 if dag >= 35 & dag <= 39
replace ageGroup = 6 if dag >= 40 & dag <= 59
replace ageGroup = 7 if dag >= 60 & dag <= 79
replace ageGroup = 8 if dag >= 80 & dag <= 100

label def ageGrouplb /// 
	0 "ageGroup_0_14" ///
	1 "ageGroup_15_19" ///
	2 "ageGroup_20_24" ///
	3 "ageGroup_25_29" ///
	4 "ageGroup_30_34" ///
	5 "ageGroup_35_39" ///
	6 "ageGroup_40_59" ///
	7 "ageGroup_60_79" ///
	8 "ageGroup_80_100" ///
	
label val ageGroup ageGrouplb
fre ageGroup

gen ageGroup2 = .
replace ageGroup2 = 0 if dag >= 16 & dag <= 24
replace ageGroup2 = 1 if dag >= 25 & dag <= 29
replace ageGroup2 = 2 if dag >= 30 & dag <= 34
replace ageGroup2 = 3 if dag >= 35 & dag <= 39
replace ageGroup2 = 4 if dag >= 40 & dag <= 44
replace ageGroup2 = 5 if dag >= 45 & dag <= 49
replace ageGroup2 = 6 if dag >= 50 & dag <= 54
replace ageGroup2 = 7 if dag >= 55 & dag <= 59
replace ageGroup2 = 8 if dag >= 60 & dag <= 65

label def ageGrouplb2 /// 
	0 "ageGroup_16_24" ///
	1 "ageGroup_25_29" ///
	2 "ageGroup_30_34" ///
	3 "ageGroup_35_39" ///
	4 "ageGroup_40_44" ///
	5 "ageGroup_45_49" ///
	6 "ageGroup_50_54" ///
	7 "ageGroup_55_59" ///
	8 "ageGroup_60_65" ///
	
label val ageGroup2 ageGrouplb2
fre ageGroup2

* Sex
replace dgn = . if dgn < 0

* Self-rated health 
replace dhe = . if dhe < 0

* Define CPI used to deflate monetary values to 2015
/*Harmonised index of consumer prices (HICP)
Annual data (annual average index) 2015=100
All-items HICP
Source dataset: Eurostat (prc_hicp_aind)	
Unit Index, base year = 100
Last data update: 20/2/25
https://ec.europa.eu/eurostat/databrowser/view/...
prc_hicp_aind__custom_17211132/default/table?lang=en*/
*/
gen CPI = .
replace CPI = 84.35  if stm == 2005
replace CPI = 87.14  if stm == 2006
replace CPI = 89.75  if stm == 2007
replace CPI = 93.55  if stm == 2008
replace CPI = 94.81  if stm == 2009
replace CPI = 99.27  if stm == 2010
replace CPI = 102.36  if stm == 2011
replace CPI = 103.42  if stm == 2012
replace CPI = 102.54 if stm == 2013
replace CPI = 101.11 if stm == 2014
replace CPI = 100    if stm == 2015
replace CPI = 100.02 if stm == 2016
replace CPI = 101.15 if stm == 2017
replace CPI = 101.94 if stm == 2018
replace CPI = 102.46 if stm == 2019
replace CPI = 101.17 if stm == 2020
replace CPI = 111.21 if stm == 2021
replace CPI = 115.84 if stm == 2022
replace CPI = 119.31 if stm == 2023


*** Income variables 

**  Gross income per benefit unit (with benefits)

/*
Hh level variable already exists in EU-SILC data.

UK definition: 
fimngrs_dv 	- Total monthly personal income gross. Consists of: 
				+ income from savings and investments, 
				annual (divided by 12 to derive a monthly equivalent) 
				(fiyrinvinc_dv) 
				+ total monthly labour income gross (fimnlabgrs_dv) 
				+ Total income from benefits and other sources (fibenothr_dv) 


EU-SILC definition:
HY010		- Total gross household income is computed as sum of all gross  
				personal income of all household members collected in the 
				individual part plus gross income components collected for 
				each household.The sum for all household members of:

Gross personal income components 
• PY010G	- Gross employee cash or near cash employee income  
• PY021G	- Company car 
• PY050G	- Gross cash benefits or losses from self-employment 
				(including royalties) 
• PY080G	- Pensions received from individual private plans (other than those 
				covered under ESSPROS) 
• PY090G	- Unemployment benefits  
• PY100G	- Old-age benefits 
• PY110G	- Survivor' benefits
• PY120G	- Sickness benefits 
• PY130G	- Disability benefits 
• PY140G	- Education-related allowances 

Plus gross income components at household level 
• HY040G	- Income from rental of a property or land 
• HY050G	- Family/children-related allowances 
• HY060G	- Social exclusion not elsewhere classified 
• HY070G	- Housing allowances 
• HY080G	- Regular inter-household cash transfers received 
• HY090G	- Interests, dividends, profit from capital investments in 
				unincorporated business 
• HY110G	- Income received by people aged under 16 

Notes: 
Use the EU-SILC variable but net out company car which is not included in the UK 
definition, so it was not included either when individual non-benefit income was 
constructed for initial populations. Therefore PY021G is deducted from gross 
income.   
All income variables in SILC are annual, no need to multiply by 12 
To generate the individual and ben unit variables the hh level variables are 
divided up evenly among the hh memebers. 
Impose non-negativity on gross incomes. 

Could construct this ourselves more preciously using the individual level 
variables and just dividing up the hh variables 
*/

sort stm idhh idbenefitunit idperson  
order stm idhh idperson hy010 py021g, last 

gen one = 1 
bysort stm idhh: egen hhsize = total(one)

recode py021g (. = 0)
gen y_gross_person =  (hy010/hhsize - py021g)/12
replace y_gross_person = 0 if y_gross_person < 0 //recode negative incomes as 0
assert y_gross_person >= 0 

bys stm idhh idbenefitunit: egen y_gross_bu = total(y_gross_person)
replace y_gross_bu = y_gross_bu / (CPI/100)
gen valid_y_gross_yr_bu = y_gross_bu * 12

gen valid_y_gross_person_yr = y_gross_person * 12 / (CPI/100)


** Gross income per benefit unit without benefits

/* 
No variable in EU-SILC so need to construct using the sum of various components. 

EU-SILC definition:
The sum for all household members of:

Gross personal income components 
• PY010G - Gross employee cash or near cash employee income 
• PY050G - Gross cash benefits or losses from self-employment 
			(including royalties) 
• PY080G - Pensions received from individual private plans (other than those 
			covered under ESSPROS)
 
Plus gross income components at household level 
• HY040G - Income from rental of a property or land 
• HY080G - Regular inter-household cash transfers received 
• HY090G - Interests, dividends, profit from capital investments in 
			unincorporated business 
• HY110G - Income received by people aged under 16 

Distribute the hh level variables evenly among the adults in the hh. 
*/

* Obtain number of adults in hh 	
gen adult = (dag >= $age_become_responsible) //18 yo and over 
bysort stm idhh : egen n_adults = total(adult) 
gen child = (dag < $age_become_responsible) //below 18 yo 
bysort stm idhh : egen n_child = total(child) 

foreach var in hy080g hy110g hy040g hy090g {
	gen `var'_pc = `var'/n_adults
	replace `var'_pc = 0 if child == 1
} 

* Generate annual individual level variable 
egen y_gross_nsbc_person = rowtotal(py010g py050g py080g hy080g_pc ///
	hy110g_pc hy040g_pc hy090g_pc) 

* Account for negative labour incomes 	
/* Assume total labour income is zero if total labour income is negative to 
avoid double counting */	
egen y_gross_nsbc_person_nl = rowtotal(hy080g_pc hy110g_pc hy040g_pc hy090g_pc) 
replace y_gross_nsbc_person = y_gross_nsbc_person_nl if py010g + py050g < 0
drop y_gross_nsbc_person_nl

replace y_gross_nsbc_person = y_gross_nsbc_person / 12
replace y_gross_nsbc_person = 0 if  y_gross_nsbc_person < 0 
	//recode negative incomes as 0
assert y_gross_nsbc_person >= 0 

* Check if missing on all the components 
count if py010g >= . &  py050g >= . &  py080g >= . &  hy080g >= . &  ///
	hy110g >= . & hy040g >= . & hy090g >= . 

bys stm idhh idbenefitunit: egen y_gross_nsbc_bu = total(y_gross_nsbc_person)

replace y_gross_nsbc_bu = y_gross_nsbc_bu / (CPI/100)

gen valid_y_gross_nsbc_yr_bu = y_gross_nsbc_bu * 12

gen valid_y_gross_nsbc_person_yr = y_gross_nsbc_person * 12 / (CPI/100)


* Benefit income 
gen y_social_person = y_gross_person - y_gross_nsbc_person
gen y_social_bu = y_gross_bu - y_gross_nsbc_bu
gen valid_y_social_yr_bu = valid_y_gross_yr_bu - valid_y_gross_nsbc_yr_bu


** Disposable income 

/* 
HH level variable already exists in EU-SILC data. 

UK definition: 
fimnnet_dv	- Total net personal income – no deductions, where net refers to net
				of taxes on earnings and national insurance contributions. 
				It is constructed as the sum of the six income components. 
				
Component 1: Labour income (w_fimnlabnet_dv) 
+ Component 2: Miscellaneous income (w_fimnmisc_dv) 
+ Component 3: private benefit income (w_fimnprben_dv) 
+ Component 4: investment income (w_fimninvnet_dv) 
+ Component 5: pension income (w_fimnpen_dv)
+ Component 6: social benefit income (w_fimnsben_dv). 

EU-SILC definition: 
Total disposable household income (HY020) can be computed as: 

The sum for all household members of gross personal income components: 
• PY010G 	- Gross employee cash or near cash employee income 
• PY021G	- Company car 
• PY050G 	- Gross cash benefits or losses from self-employment 
				(including royalties) 
• PY080G	- Pensions received from individual private plans (other than those  
				covered under ESSPROS)  
• PY090G 	- Unemployment benefits 
• PY100G	- Old-age benefits 
• PY110G	- Survivor' benefits 
• PY120G	- Sickness benefits 
• PY130G	- Disability benefits
• PY140G	- Education-related allowances 

Plus gross income components at household level: 
• HY040G 	- Income from rental of a property or land 
• HY050G	- Family/children related allowances 
• HY060G 	- Social exclusion not elsewhere classified 
• HY070G	- Housing allowances 
• HY080G	- Regular inter-household cash transfers received 
• HY090G	- Interests, dividends, profit from capital investments in 
				unincorporated business 
• HY110G	- Income received by people aged under 16 

Minus 
• HY120G	- Regular taxes on wealth 
• HY130G	- Regular inter-household cash transfer paid 
• HY140G	- Tax on income and social insurance contributions 

The variable HY140G includes the income taxes paid during the income 
reference period, the tax adjustments/repayment/receipt received or paid during 
the income reference period and the social insurance contributions paid during 
the income reference period. 

That means: HY020 = HY010 – HY120G – HY130G – HY140G. 

Notes: 
PY021G (company car) deducted from hh income to be consistent with how 
income was constructed for initial populations 
Could be calculated more precisouly using individual level variables. 
*/

gen y_disp_person = (hy020/hhsize - py021g)/12 
replace y_disp_person = 0 if y_disp_person < 0 //recode negative incomes as 0
assert y_disp_person >= 0 

bys stm idhh idbenefitunit: egen y_disp_bu = total(y_disp_person)
replace y_disp_bu = y_disp_bu / (CPI/100)
gen valid_y_disp_yr_bu = y_disp_bu * 12


** Gross labour income per benefit unit 

/*
No single variable exsits in the EU-SILC data. 

UK version: 

gen yplgrs = fimnlabgrs_dv 

EU-SILC version: 
• PY010G 	- Gross employee cash or near cash employee income 
• PY050G 	- Gross cash benefits or losses from self-employment 
				(including royalties) 
*/

* Impose non-negativity of labour income assumption at the individual level 
egen y_gross_labour_person = rowtotal(py010g py050g)
replace y_gross_labour_person =  y_gross_labour_person/ 12
replace y_gross_labour_person = 0 if y_gross_labour_person < 0 

gen x = 0 
foreach var of varlist py010g py050g {  
	
    replace x = x + cond(`var' < 0, 0, `var')
	
}

bys stm idhh idbenefitunit: egen y_gross_labour_bu = ///
	total(y_gross_labour_person)
replace y_gross_labour_bu = 0 if y_gross_labour_bu < 0 
	//recode obs with negative income to 0 
assert y_gross_labour_bu >= 0 

replace y_gross_labour_bu = y_gross_labour_bu / (CPI/100)
gen valid_y_gross_labour_yr_bu = y_gross_labour_bu * 12


**  Pension income 

/* 
Variable exists in the EU-SILC data.

UK definition: 
• fimnpen_dv 		- Monthly amount of net income component 6 pension income. 
					This includes receipts reported in the income data file 
					where w_ficode equals 
					[2] a pension from a previous employer, or 
					[3] a pension from a spouses previous employer. 
					This is assumed to be reported net of tax. 

EU-SILC version: 
Reported annually
• PY080G	- Pensions received from individual private plans (other than those  
				covered under ESSPROS)  

99.98% of individuals do not have pension income 
90.07% of those >=68 yo
*/
gen y_gross_pension_person = py080g / 12
bys stm idhh idbenefitunit: egen y_gross_pension_bu = ///
	total(y_gross_pension_person)
replace y_gross_pension_bu = y_gross_pension_bu / (CPI/100)
gen valid_y_gross_pension_yr_bu = y_gross_pension_bu * 12

gen valid_y_pension_over68 = py080g / (CPI/100) if dag >= 68 & !missing(dag)


** Gross capital income  

/* 
No single variable exists in the EU-SILC data. 

UK version:   
gen capital_income_obs = fimninvnet_dv + fimnmisc_dv + fimnprben_dv

• fimninvnet_dv		- investment income
• fimnmisc_dv		- net miscellaneous income. 
						[24] educational grant (not student loan or tuition 
						fee loan), 
						[27] payments from a family member not living 
						here, or 
						[38] any other regular payment 
• fimnprben_dv 		- net private benefit income. 
						[25] trade union / friendly society payment, 
						[26] maintenance or alimony, or 
						[35] sickness  and accident insurance. 
						
EU-SILC version: 
• HY040G 	- Income from rental of a property or land 
• HY080G	- Regular inter-household cash transfers received 
• HY090G	- Interests, dividends, profit from capital investments in 
				unincorporated business 
• HY110G	- Income received by people aged under 16 
						
*/
egen y_gross_capital_person = rowtotal(hy080g_pc hy110g_pc hy040g_pc hy090g_pc) 
replace y_gross_capital_person = y_gross_capital_person / 12

bys stm idhh idbenefitunit: egen y_gross_capital_bu = ///
	total(y_gross_capital_person)
replace y_gross_capital_bu = 0 if y_gross_capital_bu < 0 
	//recode obs with negative income to 0 
assert y_gross_capital_bu >= 0 

replace y_gross_capital_bu = y_gross_capital_bu / (CPI/100)
gen valid_y_gross_capital_yr_bu = y_gross_capital_bu * 12


* Equivalised disposable income 

* Generate number of dependent children in a benefit unit
gen depChild = 1 if (dag >= 0 & dag < $age_become_responsible) 
bys swv idhh idbenefitunit: egen dnc = sum(depChild)

lab var dnc "Number of dependent children 0 - 17"

gen depChild02 = 1 if (dag >= 0 & dag <= 2) 
bys swv idhh idbenefitunit: egen dnc02 = sum(depChild02)

lab var dnc02 "Number of dependent children 0 - 2"

* Generate modified-OECD equivalence scale: 1 for the household head, 0.5 for 
* additional adults, 0.3 for children < 14 years old 
bys swv idhh idbenefitunit: gen people_in_hh = _N
cap drop child 
gen child = (dag < 14)
bys swv idhh idbenefitunit: egen children_in_hh = total(child) 
gen other_adults = people_in_hh - children_in_hh - 1 
	// -1 for the household head

gen equiv_factor = 1 + (0.5 * other_adults) + (0.3 * children_in_hh) 
	// Start with 1 because each household must have at least the head
lab var equiv_factor "OECD-modified scale equivalence factor"

gen valid_y_eq_disp_yr_bu = valid_y_disp_yr_bu / equiv_factor 

drop child people_in_hh child children_in_hh other_adults

bys year: sum valid_y*


** Annual income shares 

* Generate indiviudal level annual real variables 
gen gross_income = y_gross_nsbc_person * 12 / (CPI/100)
gen net_income = y_disp_person * 12 / (CPI/100)
gen gross_labour_income = y_gross_labour_person * 12 / (CPI/100)
gen pension_income = y_gross_pension_person * 12 / (CPI/100)
gen capital_income = y_gross_capital_person * 12 / (CPI/100)
gen social_income = y_social_person * 12 / (CPI/100)

* Aggregate observed values to benefit unit level
// these are already generated above  valid_y_gross_labour_yr_bu? 
foreach observed_var in gross_income net_income gross_labour_income ///
	pension_income capital_income social_income {
	
	replace `observed_var' = 0 if `observed_var' < 0 | `observed_var' == . 
	
	bys year idhh idbenefitunit: egen `observed_var'_bu = total(`observed_var')

}

* Generate ben unit level fractions of income 
gen gross_labour_income_share_bu = gross_labour_income_bu / gross_income_bu
gen pension_income_share_bu = pension_income_bu / gross_income_bu
gen capital_income_share_bu = capital_income_bu / gross_income_bu
gen social_income_share_bu = social_income_bu / gross_income_bu
gen net_income_share_bu = net_income_bu / gross_income_bu

* If some components = 0 , share will be missing hence we need to recode it to 0
foreach observed_var in gross_labour_income_share_bu ///
	pension_income_share_bu capital_income_share_bu ///
	social_income_share_bu net_income_share_bu {
	
	replace `observed_var' = 0 if `observed_var' == . 
	
	assert `observed_var' != . 
	
}  

* Max age in BU 
bys year idhh idbenefitunit: egen max_age_in_bu = max(dag)

**  Gross income deciles (ben unit)

/*
xtile obs_gross_income_group = gross_income_bu, nq(10)  
	This is not correct for pooled data

Problem: if many observations have exactly the same value, xtile would group 
them into a single decile, causing one or more deciles to have very few 
observations. 
Adding a very small random amount can help differentiate tied values enough to 
distribute them more evenly across deciles without distorting the data 
meaningfully.
*/
gen gross_income_bu_jittered = gross_income_bu + runiform() * 1e-5

forvalues stm = 2011/$max_year {
	
	xtile obs_gross_income_group_`stm' = gross_income_bu_jittered if ///
		depChild != 1 & stm == `stm', nq(10)
		
	bys idhh: egen temp_obs_gross_income_group_`stm' = ///
		max(obs_gross_income_group_`stm') if stm == `stm'
		
	replace obs_gross_income_group_`stm' = ///
		temp_obs_gross_income_group_`stm' if ///
		missing(obs_gross_income_group_`stm')
	drop temp_obs_gross_income_group_`stm'

} 

* Unify into a single variable 
egen obs_gross_income_group = rowtotal(obs_gross_income_group_2011 ///
	obs_gross_income_group_2012 obs_gross_income_group_2013 ///
	obs_gross_income_group_2014 obs_gross_income_group_2015 ///
	obs_gross_income_group_2016 obs_gross_income_group_2017 ///
	obs_gross_income_group_2018 obs_gross_income_group_2019 ///
	obs_gross_income_group_2020 obs_gross_income_group_2021 ///
	obs_gross_income_group_2022 obs_gross_income_group_2023)

drop obs_gross_income_group_2*
bys stm: fre obs_gross_income_group


**  Activity status 

/* EU-SILC version: 

PL031 - Self defined current economic status 
	1	Employee working full-time	
	2	Employee working part-time	
	3	Self-employed working full-time (including family worker)	
	4	Self-employed working part-time (including family worker)	
	5	Unemployed	2427	
	6	Pupil, student, further training, unpaid work experience	
	7	In retirement or in early retirement or has given up business	
	8	Permanently disabled or/and unfit to work	
	10	Fulfilling domestic tasks and care responsibilities	
	11	Other inactive person	
	
RB210 - Basic activity status
	1	At work	
	2	Unemployed	
	3	In retirement or early retirement	
	4	Other inactive person	

PL032 - Self defined current economic status 	
	1	Employed	
	2	Unemployed	
	3	Retired	
	4	Unable to work due to long-standing health problems	
	5	Student, pupil	
	6	Fulfilling domestic tasks	
	7	Compulsory military or civilian service	
	8	Other

RB211 - Main activity status (self-defined)
	1	Employed	
	2	Unemployed	
	3	Retired	
	4	Unable to work due to long-standing health problems	
	5	Student, pupil	
	6	Fulfilling domestic tasks	
	8	Other	

PL040A - Status in employement 	
	1	Self-employed with employees	
	2	Self-employed without employees	
	3	Employee	
	4	Family worker (unpaid)
*/

* 1 - Without retirement separated out 
* 2009-2020
recode pl031 (1 2 3 4 = 1 "Employed or self-employed") ///
	(6 = 2 "Student") /// 
	(5 7 8 10 11 = 3 "Not employed") /// 
	, into(les_c3)
	
lab var les_c3 "LABOUR MARKET: Activity status"

* 2021-2023
replace les_c3 = 1 if les_c3 == . & pl032 == 1
replace les_c3 = 2 if les_c3 == . & pl032 == 5
replace les_c3 = 3 if les_c3 == . & inrange(pl032,2,4)
replace les_c3 = 3 if les_c3 == . & inrange(pl032,6,8)


* Utilizing alternative raw variables 
* 2005-2020 
replace les_c3 = 1 if rb210 == 1 & les_c3 == .
replace les_c3 = 3 if inrange(rb210,2,4) & les_c3 == .

* 2021-2023
replace les_c3 = 1 if rb211 == 1 & les_c3 == .
replace les_c3 = 2 if rb211 == 5 & les_c3 == . 	
replace les_c3 = 3 if (inrange(rb211,2,4) | rb211 == 6 | rb211 == 8 ) & ///
	les_c3 == .
	
* For people 16 and under set activity status to student
replace les_c3 = 2 if dag <= 16 

* In simulation only permitted to return to education until the age of 35 
replace les_c3 = 3 if les_c3 == 2 & dag > 35 

* In simulation can only work when can leave home (18+)
replace les_c3 = 3 if dag < 17 & les_c3 != 2 


* 2 - With retirement separated out 

* Activity status variable adding retirement
clonevar les_c4 = les_c3

replace les_c4 = 4 if pl031 == 7 | pl032 == 3 

replace les_c4 = 4 if pl031 == . &  rb210 == 3 
replace les_c4 = 4 if pl032 == . & rb211 == 3 

lab var les_c4 "LABOUR MARKET: Activity status, inc retirement"
lab define les_c4  1 "Employed or self-employed"  2 "Student"  ///
	3 "Not employed"  4 "Retired"
lab val les_c4 les_c4

tab2 les_c3 les_c4

// AB: Some students/working are retired, corrected so report not employed 
* Impose consistency across les_c3 and les_c4
replace les_c3 = 3 if les_c4 == 4  //0 changes

* Make consistent with les_c3 
replace les_c3 = 3 if les_c4 == 4 

* Activity dummies 
gen valid_employed = (les_c4 == 1)
gen valid_student = (les_c4 == 2)
gen valid_inactive = (les_c4 == 3)
gen valid_retired = (les_c4 == 4)


**  Education level 
/*
EU SILC variables: Variables top coded 
PE040 - Highest ISCED evel attained
	0		Pre-primary education	
	1		Primary education	
	2		Lower secondary education	
	3		(Upper) secondary education	
	4		Post-secondary non-tertiary education	
	5		1st & 2nd stage of tertiary education	
	100		Primary education	
	200		Lower secondary education 
	300		Upper secondary education (not further specified)
	344		Level completion, with direct access to tertiary education	
	353		Level completion, without direct access to tertiary education	
	354		Level completion, with direct access to tertiary education	
	400		Post-secondary non-tertiary education (not further specified) 
	450		Vocational education	
	500		Short cycle tertiary	

PE041- Highest ISCED evel attained
	0		No formal education or below ISCED 1	
	100		ISCED 1 Primary education	161	0.6	1.9
	200		ISCED 2 Lower secondary education 
	340		ISCED 3 Upper secondary education- general
	344		ISCED 3 Upper secondary education (general) 
			- level completion, w/ direct access to tertiary education 
	350		ISCED 3 Upper secondary education - vocational (age 35 and over)	
	353		ISCED 3 Upper secondary education (vocational) 
			- level completion, w/o direct access to tertiary education 
	354		ISCED 3 Upper secondary education (vocational) 
			- level completion, w/ direct access to tertiary education 
	450		ISCED 4 Post-secondary non-tertiary education - vocational	
	500		IT: ISCED 5 
*/
replace pe040 = . if pe040 < 0

gen deh_c3 = .

* 2011-2020
replace deh_c3 = 3 if pe040 == 0 | pe040 == 1 | pe040 == 2 | ///
	pe040 == 100 | pe040 == 200
replace deh_c3 = 2 if pe040 == 3 | pe040 == 4 | (pe040 >= 300 & pe040 < 500)
replace deh_c3 = 1 if pe040 == 5 | pe040 == 6 | ///
	(pe040 >= 500 & pe040 <= 1000)

* 2021-2023	
replace deh_c3 = 3 if pe041 == 0 | pe041 == 100 | pe041 == 200
replace deh_c3 = 2 if (pe041 >= 300 & pe041 < 500)
replace deh_c3 = 1 if (pe041 >= 500 & pe041 <= 1000)	
	
la var deh_c3 "Education status"
label define l_deh_c3 3 "low" 2 "medium" 1 "high"
label values deh_c3 l_deh_c3
		
* Assumed in school until 17 		
replace deh_c3 = 3 if dag <= 16 & dag > -9 
replace deh_c3 = -9 if deh_c3 == . 

* Attainment dummies 
gen valid_edu_high = (deh_c3 == 1)
gen valid_edu_med = (deh_c3 == 2)
gen valid_edu_low = (deh_c3 == 3) // doesn't account for missing values 


* Partnership status
replace dcpst = . if dcpst < 0 
 
gen valid_dcpst_p = (dcpst == 1) // partnered
gen valid_dcpst_snm = (dcpst == 2) // single never married
gen valid_dcpst_prvp = (dcpst == 3) // previously partnered
gen valid_dcpst_snmprvp = (dcpst == 2 | dcpst == 3) 
	// single never married & previously partnered

* Number of children
gen children_0 = (dnc == 0)
gen children_1 = (dnc == 1)
gen children_2 = (dnc == 2)
gen children_3plus = (dnc >= 3 & dnc != .)


* Intersect partnership status and number of children
foreach var1 in valid_dcpst_p valid_dcpst_snm valid_dcpst_prvp ///
	valid_dcpst_snmprvp {
	
	foreach var2 in children_0 children_1 children_2 children_3p {
		gen `var1'_`var2' = (`var1' & `var2')
	}

}

** Hours worked  (weekly) 
/*
PL060 - Number of hours usually worked per week in current main job 
*/
clonevar lhw = pl060

la var lhw "Hours worked per week"

replace lhw = . if lhw < 0 
gen valid_lhw = lhw * 52

* Hours of work per week
gen hours = lhw

* Labour supply categories
gen laboursupplyweekly_hu = "ZERO"
replace laboursupplyweekly_hu = "TWENTY" if hours >= 1 & hours < 40
replace laboursupplyweekly_hu = "FORTY" if hours == 40 
replace laboursupplyweekly_hu = "FIFTY" if hours > 40 & !missing(hours)


/* Consider winsorizing/trimming the gross labour income 

. sum	gross_labour_income if gross_labour_income>0,	de

                     gross_labour_income
-------------------------------------------------------------
      Percentiles      Smallest
 1%     11.81617       .0004472
 5%     41.34578       .0023916
10%      211.215       .0023916       Obs             132,720
25%      1943.57       .0023916       Sum of wgt.     132,720

50%     5028.186                      Mean            5701.87
                        Largest       Std. dev.      7283.973
75%     7811.984         221851
90%     11195.03       245818.7       Variance       5.31e+07
95%     14144.34       274141.3       Skewness       102.3414
99%     23348.25        1726760       Kurtosis       23541.73

*/
gen valid_wage_hour = .
replace valid_wage_hour = gross_labour_income / valid_lhw if lhw >= 1 & ///
	lhw <= 100 
	
save "$dir_data/${country}-eusilc_validation_full_sample.dta", replace

	
* Restrict sample to individuals between min and max age defined in 
* 00_master file
keep if dag>= $min_age & dag <= $max_age

save "$dir_data/${country}-eusilc_validation_sample.dta", replace


/*

/* Investigating capital shares */

// how many BU have no gross income?
sum gross_income_bu
count if gross_income_bu == 0 
	// 65,775 obs have no gross income from labour, capital or private pension 
	// 20% of bs have no gross income 
	
// one observation per BU - could omit to get rid of arbitrary deleting 
sort year idbenefitunit 	
drop if idbenefitunit == idbenefitunit[_n-1] & year == year[_n-1] 

cap drop obs_gross_income_group
xtile obs_gross_income_group = gross_income_bu, nq(10)

//26% of BU have no gross income 
sum hy080g_pc if obs_gross_income_group == 3, de
sum hy110g_pc if obs_gross_income_group == 3, de
sum hy040g_pc if obs_gross_income_group == 3, de
sum hy090g_pc if obs_gross_income_group == 3, de
// inter hh transfer and child income are the largest sources 

sum py010g if obs_gross_income_group == 3, de
sum py050g if obs_gross_income_group == 3, de
// most don't have labour income 

// pension income small for all 


foreach var in hy080g_pc hy110g_pc hy040g_pc hy090g_pc py010g py050g {
	
	gen d_`var' = (`var' != 0)
	
}

tab d_hy080g_pc if obs_gross_income_group == 3 // 35% inter-hh transfers
tab d_hy110g_pc if obs_gross_income_group == 3 // 13% child income
tab d_hy040g_pc if obs_gross_income_group == 3 // 6% rental income
tab d_hy090g_pc if obs_gross_income_group == 3 // 7% capital investments
tab d_py010g if obs_gross_income_group == 3 // 16% wages 
tab d_py050g if obs_gross_income_group == 3 // 17% self employment  

gen ind_work_income = (d_py010g == 1 | d_py050g == 1)
tab ind_work_income if obs_gross_income_group == 3

// => 68% report no income from work 



tab hhsize if obs_gross_income_group == 3

/*
     hhsize |      Freq.     Percent        Cum.
------------+-----------------------------------
          1 |        747        8.93        8.93
          2 |      1,624       19.41       28.33
          3 |      1,848       22.08       50.42
          4 |      1,660       19.84       70.26
          5 |      1,168       13.96       84.21
          6 |        739        8.83       93.04
          7 |        343        4.10       97.14
          8 |        130        1.55       98.70
          9 |         44        0.53       99.22
         10 |         47        0.56       99.78
         11 |         12        0.14       99.93
         12 |          4        0.05       99.98
         15 |          2        0.02      100.00	*/



* Age 
histogram dag if obs_gross_income_group == 3 // U-shaped 

* Activity 
tab les_c3 if obs_gross_income_group == 3 // 57% not employed, 19% students 
