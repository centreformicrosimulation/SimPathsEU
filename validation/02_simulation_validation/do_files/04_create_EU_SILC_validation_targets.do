/*******************************************************************************
* PROJECT:  		SimPaths EU
* SECTION:			Validation
* OBJECT: 			Targets
* AUTHORS:			Patryk Bronka, Ashley Burdett, Daria Popova 
* LAST UPDATE:		Nov 2025 (AB)
* COUNTRY: 			Poland 
********************************************************************************
* DESCRIPTION:      This file creates validation targets using longitudinal EU 
* 					SILC data 
* 					generated by do files


* NOTES: 			Consider trimming gross labour income at the 
*					bottom of the file. 
*******************************************************************************/

* Load initial populations (from 05_ weight adjusted for grossing)
use "$dir_init_pop_data/${country}_pooled_ipop.dta", clear

// alternative option would be to use the estimation sample and after benefit units have been created "03_"


* Restrict sample to observations up to and including specified maximum year
fre swv
keep if swv <= $max_year
gen year = stm 


**  Age groups
gen ageGroup = .
replace ageGroup = 0 if dag >= 0 & dag <= 14
replace ageGroup = 1 if dag >= 15 & dag <= 19
replace ageGroup = 2 if dag >= 20 & dag <= 24
replace ageGroup = 3 if dag >= 25 & dag <= 29
replace ageGroup = 4 if dag >= 30 & dag <= 34
replace ageGroup = 5 if dag >= 35 & dag <= 39
replace ageGroup = 6 if dag >= 40 & dag <= 59
replace ageGroup = 7 if dag >= 60 & dag <= 79
replace ageGroup = 8 if dag >= 80 & dag <= 100

label def ageGrouplb /// 
	0 "ageGroup_0_14" ///
	1 "ageGroup_15_19" ///
	2 "ageGroup_20_24" ///
	3 "ageGroup_25_29" ///
	4 "ageGroup_30_34" ///
	5 "ageGroup_35_39" ///
	6 "ageGroup_40_59" ///
	7 "ageGroup_60_79" ///
	8 "ageGroup_80_100" ///
	
label val ageGroup ageGrouplb
fre ageGroup

gen ageGroup2 = .
replace ageGroup2 = 0 if dag >= 16 & dag <= 24
replace ageGroup2 = 1 if dag >= 25 & dag <= 29
replace ageGroup2 = 2 if dag >= 30 & dag <= 34
replace ageGroup2 = 3 if dag >= 35 & dag <= 39
replace ageGroup2 = 4 if dag >= 40 & dag <= 44
replace ageGroup2 = 5 if dag >= 45 & dag <= 49
replace ageGroup2 = 6 if dag >= 50 & dag <= 54
replace ageGroup2 = 7 if dag >= 55 & dag <= 59
replace ageGroup2 = 8 if dag >= 60 & dag <= 65

label def ageGrouplb2 /// 
	0 "ageGroup_16_24" ///
	1 "ageGroup_25_29" ///
	2 "ageGroup_30_34" ///
	3 "ageGroup_35_39" ///
	4 "ageGroup_40_44" ///
	5 "ageGroup_45_49" ///
	6 "ageGroup_50_54" ///
	7 "ageGroup_55_59" ///
	8 "ageGroup_60_65" ///
	
label val ageGroup2 ageGrouplb2
fre ageGroup2

** Sex
replace dgn = . if dgn < 0


*** Income variables - all annual unless stated

** Real gross income (non-benefit)
* by individual 
gen ypnb = sinh(ypnbihs_dv) 
gen valid_y_gross_ind_yr = ypnb * 12

* by benefit unit
bys stm idhh idbenefitunit: ///
	egen valid_y_gross_bu_yr = total(valid_y_gross_ind_yr)

	
** Disposable income 
* by individual 
merge 1:1 idperson swv using "$dir_data/silc_ind_dispos_y.dta"
drop if _m == 2 
drop _m 

* by benefit unit 
bys stm idhh idbenefitunit: ///
	egen valid_y_disp_bu_yr = total(valid_y_disp_ind_yr)


** Real gross labour income 
* by individual
gen y_gross_labour_ind_yr = sinh(yplgrs_dv) * 12

* by benefit unit 
bys stm idhh idbenefitunit: ///
	egen valid_y_gross_labour_bu_yr = total(y_gross_labour_ind_yr) 

** Real capital income 
* by benefit unit 
gen y_gross_capital_ind_yr = sinh(ypncp) * 12

* by benefit unit 
bys stm idhh idbenefitunit: ///
	egen valid_y_gross_capital_bu_yr = total(y_gross_capital_ind_yr) 

	
* Equivalised disposable income per benefit unit 
* Generate number of dependent children in a benefit unit
gen depChild = 1 if (dag >= 0 & dag < $age_become_responsible) 
bys swv idhh idbenefitunit: egen dnc_bu = sum(depChild)

gen depChild02 = 1 if (dag >= 0 & dag <= 2) 
bys swv idhh idbenefitunit: egen dnc02_bu = sum(depChild02)

lab var dnc02 "Number of dependent children 0 - 2"

* Generate modified-OECD equivalence scale: 1 for the household head, 0.5 for 
* additional adults, 0.3 for children < 14 years old 
bys swv idhh idbenefitunit: gen people_in_bu = _N
cap drop child 
gen child = (dag < 14)
bys swv idhh idbenefitunit: egen children_in_bu = total(child) 
gen other_adults = people_in_bu - children_in_bu - 1 
	// -1 for the household head

gen equiv_factor = 1 + (0.5 * other_adults) + (0.3 * children_in_bu) 
	// Start with 1 because each household must have at least the head
lab var equiv_factor "OECD-modified scale equivalence factor"

gen valid_y_eq_disp_bu_yr = valid_y_disp_bu_yr / equiv_factor 

drop child people_in_bu child children_in_bu other_adults dnc_bu dnc02_bu


** Annual income shares 
/*
xtile obs_gross_income_group = valid_y_gross_bu_yr, nq(10)  
	This is not correct for pooled data

Problem: if many observations have exactly the same value, xtile would group 
them into a single decile, causing one or more deciles to have very few 
observations. 
Adding a very small random amount can help differentiate tied values enough to 
distribute them more evenly across deciles without distorting the data 
meaningfully.
*/
gen valid_y_gross_bu_yr_jit = valid_y_gross_bu_yr + runiform() * 1e-5

forvalues stm = 2011/$max_year {
	
	xtile obs_gross_income_group_`stm' = valid_y_gross_bu_yr_jit if ///
		depChild != 1 & stm == `stm', nq(10)
		
	bys idhh: egen temp_obs_gross_income_group_`stm' = ///
		max(obs_gross_income_group_`stm') if stm == `stm'
		
	replace obs_gross_income_group_`stm' = ///
		temp_obs_gross_income_group_`stm' if ///
		missing(obs_gross_income_group_`stm')
	drop temp_obs_gross_income_group_`stm'

} 

* Unify into a single variable 
egen obs_gross_income_group = rowtotal(obs_gross_income_group_2011 ///
	obs_gross_income_group_2012 obs_gross_income_group_2013 ///
	obs_gross_income_group_2014 obs_gross_income_group_2015 ///
	obs_gross_income_group_2016 obs_gross_income_group_2017 ///
	obs_gross_income_group_2018 obs_gross_income_group_2019 ///
	obs_gross_income_group_2020 obs_gross_income_group_2021 ///
	obs_gross_income_group_2022 obs_gross_income_group_2023)

drop obs_gross_income_group_2*
bys stm: fre obs_gross_income_group

**  Activity status 
* Activity dummies 
gen valid_employed = (les_c4 == 1)
gen valid_student = (les_c4 == 2)
gen valid_inactive = (les_c4 == 3)
gen valid_retired = (les_c4 == 4)

replace valid_employed = . if les_c4 < 0 | les_c4 == . 
replace valid_student = . if les_c4 < 0 | les_c4 == . 
replace valid_inactive = . if les_c4 < 0 | les_c4 == . 
replace valid_retired = . if les_c4 < 0 | les_c4 == . 


**  Education level 
* Attainment dummies 
replace deh_c3 = 3 if ded == 1 

gen valid_edu_high = (deh_c3 == 1)
gen valid_edu_med = (deh_c3 == 2)
gen valid_edu_low = (deh_c3 == 3) 

/*
replace valid_edu_high = . if deh_c3 == . | deh_c3 < 0 | deh_flag == 1
replace valid_edu_med = . if deh_c3 == . | deh_c3 < 0 | deh_flag == 1
replace valid_edu_low = . if deh_c3 == . | deh_c3 < 0 | deh_flag == 1
*/ 

**  Family
* Partnership status  
gen valid_dcpst_p = (dcpst == 1) // partnered
gen valid_dcpst_s = (dcpst == 2) // single 

replace valid_dcpst_p = . if dcpst == . | dcpst < 0 
replace valid_dcpst_s = . if dcpst == . | dcpst < 0 

* Number of children
gen children_0 = (dnc == 0)
gen children_1 = (dnc == 1)
gen children_2 = (dnc == 2)
gen children_3plus = (dnc >= 3 & dnc != .)

* Interaction of partnership status and number of children
foreach var1 in valid_dcpst_p valid_dcpst_s {
	
	foreach var2 in children_0 children_1 children_2 children_3p {
	
		gen `var1'_`var2' = (`var1' & `var2')
	
	}

}


** Self-rated health 
replace dhe = . if dhe < 0 | dhe_flag == 1 


** Hours worked (weekly) 

* Impose consistency with les_c4 
* Prioritize les_c4 as we did with the European models
replace lhw = . if les_c4 != 1

count if (lhw == 0 | lhw == .) & les_c4 == 1
// note that 0s could be generated from missing values in rowtotal function

tab les_c4 if lhw != 0 & lhw != .

gen hours = lhw
gen valid_lhw = lhw 


* Labour supply categories
gen laboursupplyweekly_hu = "ZERO"
replace laboursupplyweekly_hu = "TWENTY" if hours >= 1 & hours < 40
replace laboursupplyweekly_hu = "FORTY" if hours == 40 
replace laboursupplyweekly_hu = "FIFTY" if hours > 40 & !missing(hours)


* Hourly wages 
gen valid_wage_hour = .
replace valid_wage_hour = obs_earnings_hourly
replace valid_wage_hour = . if obs_earnings_hourly < 0 

replace valid_wage_hour = . if valid_wage_hour == 0 & les_c4 == 1


* Minimum wage variable 
gen min_wage = 8.66 if swv == 2011
replace min_wage = 9.38 if swv == 2012
replace min_wage = 10.00 if swv == 2013
replace min_wage = 10.5 if swv == 2014
replace min_wage = 10.64 if swv == 2015
replace min_wage = 11.56 if swv == 2016
replace min_wage = 12.50 if swv == 2017
replace min_wage = 13.13 if swv == 2018
replace min_wage = 14.06 if swv == 2019
replace min_wage = 16.25 if swv == 2020
replace min_wage = 17.50 if swv == 2021
replace min_wage = 18.81 if swv == 2022
replace min_wage = 22.8 if swv == 2023

* Convert into real terms
replace min_wage = min_wage * (CPI/100)


gen valid_wage_hour_adj_mw = valid_wage_hour
replace valid_wage_hour_adj_mw = min_wage if valid_wage_hour < min_wage

replace valid_wage_hour_adj = valid_wage_hour
replace valid_wage_hour_adj = . if valid_wage_hour < min_wage

	
save "$dir_data/${country}-eusilc_validation_full_sample_long.dta", replace

	
* Restrict sample to individuals between min and max age defined in 
* 00_master file
keep if dag>= $min_age & dag <= $max_age

save "$dir_data/${country}-eusilc_validation_sample_long.dta", replace
